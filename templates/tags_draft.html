<!DOCTYPE html>
<meta charset="utf-8">
<style type="text/css">
  /*to be changed later*/
  text {
    font: 12px sans-serif;

  }
  circle {
      stroke: #636363;
      stroke-width: 1;
      opacity: 1;
  }
  div.tooltip{
    /*visibility:hidden;*/
    position: absolute;
    color: white;
    padding: 8px;
    background-color: #626D71;
    border-radius: 6px;
    text-align: center;
    font-family: monospace; 
    width: 200px;
  }
</style>

<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<body>
  <div id='matchScore' data-username1='{{ username1 }}' data-username2= '{{ username2 }}' ><h3>{{ username1 }} and {{ username2}} is {{ match_score }} MATCH!</h3></div>
  <div>
    <select id='text-source' name='text-source'>
      <option value='tags'>Photo Tags</option>
      <option value='title'>Photo Title</option>
      <option value='description'>Photo Description</option>
    </select>
  </div>
</body>

<script>

  function updateGraph() {
    username1 = $('#matchScore').data('username1');
    username2 = $('#matchScore').data('username2');
    url = '/tags-bubble'
    
    if ($('#text-source').val() == 'tags') {
      $.post(url, {'texttype': 'tags', 'username1': username1,'username2': username2}, function(results){
        console.log(results);
        // bubbleGraph(results);
        d3.select("svg").remove();
        updateTags();
        console.log('finish');
      });
    }

    if ($('#text-source').val() == 'title') {
      $.post(url, {'texttype': 'title', 'username1': username1,'username2': username2},function(results){
        console.log(results);
        d3.select("svg").remove();
        console.log('finish');
        updateTitle();
        // bubbleGraph(results);

      });
    }

    if ($('#text-source').val() == 'description') {
      $.post(url, {'texttype': 'description', 'username1': username1,'username2': username2}, function(results){
        console.log(results);
        d3.select("svg").remove();
        updateDescription();

      });
    }
  }

  $('#text-source').on('change', updateGraph);

    // D3 global variables
  var width = 1200,
      height = 800,
      padding = 1.5, // separation between same-color nodes
      clusterPadding = 8, // separation between different-color nodes
      maxRadius = 20;

  var color = d3.scale.ordinal()
        .range([ "#dbdb8d", 'c7c7c7', '#2ad1f7']);

  var opacity = d3.scale.ordinal()
        .range([0.4, 0.4, 1])


  //D3 function that display given textUrl
  function updateTags() {
    d3.text("static/tags.csv", function(error, text) {
        if (error) throw error;

        var colNames = "word,count,user\n" + text;
        var data = d3.csv.parse(colNames);

        data.forEach(function(d) {
          d.count = +d.count;
        });

      //unique cluster/user id's
      var cs = [];
      data.forEach(function(d){
              if(!cs.contains(d.user)) {
                  cs.push(d.user);
              }
      });

      var n = data.length, // total number of nodes
          m = cs.length; // number of distinct clusters

      //create clusters and nodes
      var clusters = new Array(m);
      var nodes = [];
      for (var i = 0; i<n; i++){
          nodes.push(create_nodes(data,i));
      }

      var force = d3.layout.force()
          .nodes(nodes)
          .size([width, height])
          .gravity(0.05)
          .charge(-10)
          .on("tick", tick)
          .start();

      var svg = d3.select("body").append("svg");

      // svg.selectAll("*").remove();

      svg.attr("width", width)
          .attr("height", height);

      var div = d3.select("body").append("div") 
        .attr("class", "tooltip")       
        .style("opacity", 1);

      var node = svg.selectAll("circle")
          .data(nodes)
          .enter().append("g").call(force.drag);

      node.append("circle")
          .style("fill", function (d) {
            return color(d.cluster);
          })
          .style("opacity", function (d) {
            return opacity(d.cluster)
          })
          .attr("r", function(d){return d.radius});
          
      let textNode = node.append("text")
            .attr("dy", ".3em")
            .style("text-anchor", "middle")
            // .text(function(d) {return d.word + "&#xA;" + d.count}) 
              // { return d.text.substring(0, d.radius / 3); });
      textNode.append('tspan')
            .attr("x", "0")            
            .attr("dy", "0em")
            .text(function(d) {return d.word});
 
      textNode.append('tspan')
            .attr("x", "0")
            .attr("dy", "1em")
            .text(function(d) {return d.count});

      node.on("mouseover", function(d) {     
              div.transition()   
                .duration(100)
                .attr('x', d.x)    
                .attr('y', d.y)
                .style("opacity", 1);
              div.html(d.user + "<br>" + d.word + "<br>" + d.count + " tags");                         
              })
          .on("mousemove", function() {
              div.style("top", (d3.event.pageY - 10) + "px")
                .style("left", (d3.event.pageX + 10) + "px");
            })      
          .on("mouseout", function() {   
              div.transition()   
                .duration(100)    
                .style("opacity", 0);
                // .style("visibility", "hidden");
            });

      function create_nodes(data,node_counter) {
        var i = cs.indexOf(data[node_counter].user),//return the first index
            r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,
            d = {
              cluster: i,
              radius: data[node_counter].count*5,
              text: data[node_counter].word + ':' + data[node_counter].count,
              word: data[node_counter].word,
              user: data[node_counter].user,
              count: data[node_counter].count,
              x: Math.cos(i / m * 2 * Math.PI) * 200 + width / 2 + Math.random(),
              y: Math.sin(i / m * 2 * Math.PI) * 200 + height / 2 + Math.random()
            };
        if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
        return d;
      };

      function tick(e) {
          node.each(cluster(5 * e.alpha * e.alpha))
              .each(collide(.3))
          .attr("transform", function (d) {
              var k = "translate(" + d.x + "," + d.y + ")";
              return k;
          })
      }

      // Move d to be adjacent to the cluster node.
      function cluster(alpha) {
          return function (d) {
              var cluster = clusters[d.cluster];
              if (cluster === d) return;
              var x = d.x - cluster.x,
                  y = d.y - cluster.y,
                  l = Math.sqrt(x * x + y * y),
                  r = d.radius + cluster.radius;
              if (l != r) {
                  l = (l - r) / l * alpha;
                  d.x -= x *= l;
                  d.y -= y *= l;
                  cluster.x += x;
                  cluster.y += y;
              }
          };
      }

      // Resolves collisions between d and all other circles.
      function collide(alpha) {
          var quadtree = d3.geom.quadtree(nodes);
          return function (d) {
              var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                  nx1 = d.x - r,
                  nx2 = d.x + r,
                  ny1 = d.y - r,
                  ny2 = d.y + r;
              quadtree.visit(function (quad, x1, y1, x2, y2) {
                  if (quad.point && (quad.point !== d)) {
                      var x = d.x - quad.point.x,
                          y = d.y - quad.point.y,
                          l = Math.sqrt(x * x + y * y),
                          r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
                      if (l < r) {
                          l = (l - r) / l * alpha;
                          d.x -= x *= l;
                          d.y -= y *= l;
                          quad.point.x += x;
                          quad.point.y += y;
                      }
                  }
                  return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
              });
          };
      }
    });
  }

  updateTags(); 

  function updateTitle() {

    d3.text('static/title.csv', function(error, text) {
        if (error) throw error;

        var colNames = "word,count,user\n" + text;
        var data = d3.csv.parse(colNames);

        data.forEach(function(d) {
          d.count = +d.count;
        });

      //unique cluster/user id's
      var cs = [];
      data.forEach(function(d){
              if(!cs.contains(d.user)) {
                  cs.push(d.user);
              }
      });

      var n = data.length, // total number of nodes
          m = cs.length; // number of distinct clusters

      //create clusters and nodes
      var clusters = new Array(m);
      var nodes = [];
      for (var i = 0; i<n; i++){
          nodes.push(create_nodes(data,i));
      }

      var force = d3.layout.force()
          .nodes(nodes)
          .size([width, height])
          .gravity(0.05)
          .charge(-50)
          .on("tick", tick)
          .start();

      var svg = d3.select("body").append("svg")
          .attr("width", width)
          .attr("height", height);

      var div = d3.select("body").append("div") 
        .attr("class", "tooltip")       
        .style("opacity", 1);

      var node = svg.selectAll("circle")
          .data(nodes)
          .enter().append("g").call(force.drag);

      node.append("circle")
          .style("fill", function (d) {
            return color(d.cluster);
          })
          .style("opacity", function (d) {
            return opacity(d.cluster)
          })
          .attr("r", function(d){return d.radius * 2});

      let textNode = node.append("text")
            .attr("dy", ".3em")
            .style("text-anchor", "middle")
            // .text(function(d) {return d.word + "&#xA;" + d.count}) 
              // { return d.text.substring(0, d.radius / 3); });
      textNode.append('tspan')
            .attr("x", "0")            
            .attr("dy", "0em")
            .text(function(d) {return d.word});
 
      textNode.append('tspan')
            .attr("x", "0")
            .attr("dy", "1em")
            .text(function(d) {return d.count});
          
      // node.append("text")
      //       .attr("dy", ".3em")
      //       .style("text-anchor", "middle")
      //       .text(function(d) {return d.word}) 
              // { return d.text.substring(0, d.radius / 3); });

      node.on("mouseover", function(d) {     
              div.transition()   
                .duration(100)
                .attr('x', d.x)    
                .attr('y', d.y)
                .style("opacity", 1);
              div.html(d.user + "<br>" + d.word + "<br>" + d.count + " counts");                         
              })
          .on("mousemove", function() {
              div.style("top", (d3.event.pageY - 10) + "px")
                .style("left", (d3.event.pageX + 10) + "px");
            })    
          .on("mouseout", function() {   
              div.transition()   
                .duration(100)    
                .style("opacity", 0);
                // .style("visibility", "hidden");
            });

      function create_nodes(data,node_counter) {
        var i = cs.indexOf(data[node_counter].user),//return the first index
            r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,
            d = {
              cluster: i,
              radius: data[node_counter].count*5,
              text: data[node_counter].word + ':' + data[node_counter].count,
              word: data[node_counter].word,
              user: data[node_counter].user,
              count: data[node_counter].count,
              x: Math.cos(i / m * 2 * Math.PI) * 200 + width / 2 + Math.random(),
              y: Math.sin(i / m * 2 * Math.PI) * 200 + height / 2 + Math.random()
            };
        if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
        return d;
      };

      function tick(e) {
          node.each(cluster(5 * e.alpha * e.alpha))
              .each(collide(.3))
          .attr("transform", function (d) {
              var k = "translate(" + d.x + "," + d.y + ")";
              return k;
          })
      }

      // Move d to be adjacent to the cluster node.
      function cluster(alpha) {
          return function (d) {
              var cluster = clusters[d.cluster];
              if (cluster === d) return;
              var x = d.x - cluster.x,
                  y = d.y - cluster.y,
                  l = Math.sqrt(x * x + y * y),
                  r = d.radius + cluster.radius;
              if (l != r) {
                  l = (l - r) / l * alpha;
                  d.x -= x *= l;
                  d.y -= y *= l;
                  cluster.x += x;
                  cluster.y += y;
              }
          };
      }

      // Resolves collisions between d and all other circles.
      function collide(alpha) {
          var quadtree = d3.geom.quadtree(nodes);
          return function (d) {
              var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                  nx1 = d.x - r,
                  nx2 = d.x + r,
                  ny1 = d.y - r,
                  ny2 = d.y + r;
              quadtree.visit(function (quad, x1, y1, x2, y2) {
                  if (quad.point && (quad.point !== d)) {
                      var x = d.x - quad.point.x,
                          y = d.y - quad.point.y,
                          l = Math.sqrt(x * x + y * y),
                          r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
                      if (l < r) {
                          l = (l - r) / l * alpha;
                          d.x -= x *= l;
                          d.y -= y *= l;
                          quad.point.x += x;
                          quad.point.y += y;
                      }
                  }
                  return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
              });
          };
      }
    });

  }


function updateDescription() {

    d3.text('static/description.csv', function(error, text) {
        if (error) throw error;

        var colNames = "word,count,user\n" + text;
        var data = d3.csv.parse(colNames);

        data.forEach(function(d) {
          d.count = +d.count;
        });

      //unique cluster/user id's
      var cs = [];
      data.forEach(function(d){
              if(!cs.contains(d.user)) {
                  cs.push(d.user);
              }
      });

      var n = data.length, // total number of nodes
          m = cs.length; // number of distinct clusters

      //create clusters and nodes
      var clusters = new Array(m);
      var nodes = [];
      for (var i = 0; i<n; i++){
          nodes.push(create_nodes(data,i));
      }

      var force = d3.layout.force()
          .nodes(nodes)
          .size([width, height])
          .gravity(0.06)
          .charge(-50)
          .on("tick", tick)
          .start();

      var svg = d3.select("body").append("svg")
          .attr("width", width)
          .attr("height", height);

      var div = d3.select("body").append("div") 
        .attr("class", "tooltip")       
        .style("opacity", 1);

      var node = svg.selectAll("circle")
          .data(nodes)
          .enter().append("g").call(force.drag);

      node.append("circle")
          .style("fill", function (d) {
            return color(d.cluster);
          })
          .style("opacity", function (d) {
            return opacity(d.cluster)
          })
          .attr("r", function(d){return d.radius});

      let textNode = node.append("text")
            .attr("dy", ".3em")
            .style("text-anchor", "middle")
            // .text(function(d) {return d.word + "&#xA;" + d.count}) 
              // { return d.text.substring(0, d.radius / 3); });
      textNode.append('tspan')
            .attr("x", "0")            
            .attr("dy", "0em")
            .text(function(d) {return d.word});
 
      textNode.append('tspan')
            .attr("x", "0")
            .attr("dy", "1em")
            .text(function(d) {return d.count});
          
      // node.append("text")
      //       .attr("dy", ".3em")
      //       .style("text-anchor", "middle")
      //       .text(function(d) {return d.word}) 
              // { return d.text.substring(0, d.radius / 3); });

      node.on("mouseover", function(d) {     
              div.transition()   
                .duration(100)
                .attr('x', d.x)    
                .attr('y', d.y)
                .style("opacity", 1);
              div.html(d.user + "<br>" + d.word + "<br>" + d.count + " counts");                         
              })
          .on("mousemove", function() {
              div.style("top", (d3.event.pageY - 10) + "px")
                .style("left", (d3.event.pageX + 10) + "px");
            })      
          .on("mouseout", function() {   
              div.transition()   
                .duration(100)    
                .style("opacity", 0);
                // .style("visibility", "hidden");
            });

      function create_nodes(data,node_counter) {
        var i = cs.indexOf(data[node_counter].user),//return the first index
            r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,
            d = {
              cluster: i,
              radius: data[node_counter].count*5,
              text: data[node_counter].word + ':' + data[node_counter].count,
              word: data[node_counter].word,
              user: data[node_counter].user,
              count: data[node_counter].count,
              x: Math.cos(i / m * 2 * Math.PI) * 200 + width / 2 + Math.random(),
              y: Math.sin(i / m * 2 * Math.PI) * 200 + height / 2 + Math.random()
            };
        if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
        return d;
      };

      function tick(e) {
          node.each(cluster(5 * e.alpha * e.alpha))
              .each(collide(.3))
          .attr("transform", function (d) {
              var k = "translate(" + d.x + "," + d.y + ")";
              return k;
          })
      }

      // Move d to be adjacent to the cluster node.
      function cluster(alpha) {
          return function (d) {
              var cluster = clusters[d.cluster];
              if (cluster === d) return;
              var x = d.x - cluster.x,
                  y = d.y - cluster.y,
                  l = Math.sqrt(x * x + y * y),
                  r = d.radius + cluster.radius;
              if (l != r) {
                  l = (l - r) / l * alpha;
                  d.x -= x *= l;
                  d.y -= y *= l;
                  cluster.x += x;
                  cluster.y += y;
              }
          };
      }

      // Resolves collisions between d and all other circles.
      function collide(alpha) {
          var quadtree = d3.geom.quadtree(nodes);
          return function (d) {
              var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                  nx1 = d.x - r,
                  nx2 = d.x + r,
                  ny1 = d.y - r,
                  ny2 = d.y + r;
              quadtree.visit(function (quad, x1, y1, x2, y2) {
                  if (quad.point && (quad.point !== d)) {
                      var x = d.x - quad.point.x,
                          y = d.y - quad.point.y,
                          l = Math.sqrt(x * x + y * y),
                          r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
                      if (l < r) {
                          l = (l - r) / l * alpha;
                          d.x -= x *= l;
                          d.y -= y *= l;
                          quad.point.x += x;
                          quad.point.y += y;
                      }
                  }
                  return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
              });
          };
      }
    });

  }

  // function updateBubble(textUrl) {
  //   d3.text(textUrl, function(error, text) {
  //       if (error) throw error;

  //       var colNames = "word,count,user\n" + text;
  //       var data = d3.csv.parse(colNames);

  //       data.forEach(function(d) {
  //         d.count = +d.count;
  //       });

  //     //unique cluster/user id's
  //     var cs = [];
  //     data.forEach(function(d){
  //             if(!cs.contains(d.user)) {
  //                 cs.push(d.user);
  //             }
  //     });

  //     var n = data.length, // total number of nodes
  //         m = cs.length; // number of distinct clusters

  //     //create clusters and nodes
  //     var clusters = new Array(m);
  //     var nodes = [];
  //     for (var i = 0; i<n; i++){
  //         nodes.push(create_nodes(data,i));
  //     }

  //     var force = d3.layout.force()
  //         .nodes(nodes)
  //         .size([width, height])
  //         .gravity(.1)
  //         .charge(0)
  //         .on("tick", tick)
  //         .start();

  //     var svg = d3.select("body").append("svg")
  //         .attr("width", width)
  //         .attr("height", height);

  //     var div = d3.select("body").append("div") 
  //       .attr("class", "tooltip")       
  //       .style("opacity", 1);

  //     var node = svg.selectAll("circle")
  //         .data(nodes)
  //         .enter().append("g").call(force.drag);

  //     node.append("circle")
  //         .style("fill", function (d) {
  //           return color(d.cluster);
  //         })
  //         .style("opacity", function (d) {
  //           return opacity(d.cluster)
  //         })
  //         .attr("r", function(d){return d.radius});
          
  //     let textNode = node.append("text")
  //           .attr("dy", ".3em")
  //           .style("text-anchor", "middle")
  //           // .text(function(d) {return d.word + "&#xA;" + d.count}) 
  //             // { return d.text.substring(0, d.radius / 3); });
  //     textNode.append('tspan')
  //           .attr("x", "0")            
  //           .attr("dy", "0em")
  //           .text(function(d) {return d.word});
 
  //     textNode.append('tspan')
  //           .attr("x", "0")
  //           .attr("dy", "1em")
  //           .text(function(d) {return d.count});

  //     node.on("mouseover", function(d) {     
  //             div.transition()   
  //               .duration(100)
  //               .attr('x', d.x)    
  //               .attr('y', d.y)
  //               .style("opacity", 1);
  //             div.html(d.user + "<br>" + d.word + "<br>" + d.count + " tags");                         
  //             })
  //         .on("mousemove", function() {
  //             div.style("top", (d3.event.pageY - 10) + "px")
  //               .style("left", (d3.event.pageX + 10) + "px");
  //           })      
  //         .on("mouseout", function() {   
  //             div.transition()   
  //               .duration(100)    
  //               .style("opacity", 0);
  //               // .style("visibility", "hidden");
  //           });

  //     function create_nodes(data,node_counter) {
  //       var i = cs.indexOf(data[node_counter].user),//return the first index
  //           r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,
  //           d = {
  //             cluster: i,
  //             radius: data[node_counter].count*5,
  //             text: data[node_counter].word + ':' + data[node_counter].count,
  //             word: data[node_counter].word,
  //             user: data[node_counter].user,
  //             count: data[node_counter].count,
  //             x: Math.cos(i / m * 2 * Math.PI) * 200 + width / 2 + Math.random(),
  //             y: Math.sin(i / m * 2 * Math.PI) * 200 + height / 2 + Math.random()
  //           };
  //       if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
  //       return d;
  //     };

  //     function tick(e) {
  //         node.each(cluster(5 * e.alpha * e.alpha))
  //             .each(collide(.3))
  //         .attr("transform", function (d) {
  //             var k = "translate(" + d.x + "," + d.y + ")";
  //             return k;
  //         })
  //     }

  //     // Move d to be adjacent to the cluster node.
  //     function cluster(alpha) {
  //         return function (d) {
  //             var cluster = clusters[d.cluster];
  //             if (cluster === d) return;
  //             var x = d.x - cluster.x,
  //                 y = d.y - cluster.y,
  //                 l = Math.sqrt(x * x + y * y),
  //                 r = d.radius + cluster.radius;
  //             if (l != r) {
  //                 l = (l - r) / l * alpha;
  //                 d.x -= x *= l;
  //                 d.y -= y *= l;
  //                 cluster.x += x;
  //                 cluster.y += y;
  //             }
  //         };
  //     }

  //     // Resolves collisions between d and all other circles.
  //     function collide(alpha) {
  //         var quadtree = d3.geom.quadtree(nodes);
  //         return function (d) {
  //             var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
  //                 nx1 = d.x - r,
  //                 nx2 = d.x + r,
  //                 ny1 = d.y - r,
  //                 ny2 = d.y + r;
  //             quadtree.visit(function (quad, x1, y1, x2, y2) {
  //                 if (quad.point && (quad.point !== d)) {
  //                     var x = d.x - quad.point.x,
  //                         y = d.y - quad.point.y,
  //                         l = Math.sqrt(x * x + y * y),
  //                         r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
  //                     if (l < r) {
  //                         l = (l - r) / l * alpha;
  //                         d.x -= x *= l;
  //                         d.y -= y *= l;
  //                         quad.point.x += x;
  //                         quad.point.y += y;
  //                     }
  //                 }
  //                 return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
  //             });
  //         };
  //     }
  //   });
  // }
  Array.prototype.contains = function(v) {
      for(var i = 0; i < this.length; i++) {
          if(this[i] === v) return true;
      }
      return false;
  };

</script>